# 用RTL实现最简单的处理器  
通过实现NEMU, 已经从概念上了解处理器的构成, 以及处理器大致如何工作了, 现在尝试通过RTL代码实现一个最简单的处理器。   
独立设计的处理器命名为NPC (New Processor Core)。  
## 处理器基本架构  
通过RTL代码实现PA1中的TRM（TuRing Machine）部件：  
1. PC - 本质上是一个不断加"1"的计数器，这里的"1"是指一条指令的长度  
2. 寄存器 - 这里指通用寄存器(GPR, General Purpose Register)，它通常是由一组寄存器组成的  
           (注意：从0号寄存器读出的值总是为0)  
3. 加法器 - 用于执行二进制数加法运算的器件  
4. 存储器 - 用于保存数据和指令的器件，相当于一个可以读写的“大数组”  

在数字电路实验中，涵盖以上部件的RTL代码实现方式。

按照处理器工作流程划分RTL项目模块：取指、译码、执行、更新PC：  
1. IFU(Instruction Fetch Unit): 负责根据当前PC从存储器中取出一条指令  
2. IDU(Instruction Decode Unit): 负责对当前指令进行译码, 准备执行阶段需要使用的数据和控制信号  
3. EXU(EXecution Unit): 负责根据控制信号对数据进行执行操作, 并将执行结果写回寄存器或存储器  
4. 更新PC: 通过RTL实现时, 这一操作一般与PC寄存器一同实现, 因而无需为此划分一个独立的模块  

上述部件可自行决定放置于哪一个模块中，同时梳理模块之间的接口。  
存储器是例外。为方便测试，不通过RTL代码实现存储器，而是使用C++实现。  
因此，需要将存储器访问接口的信号拉到顶层，通过C++代码访问存储器：  
```C++
while (???) {
  ...
  top->inst = pmem_read(top->pc);
  top->eval();
  ...
}
```
通过C++代码实现一个简单的存储器：
```C++

```
## 若干代码风格和规范  
- 如果使用Verilog HDL，则建议实例化+连线方式方式描述电路。  
  建议使用数据流建模和结构化建模方式，不推荐使用行为建模方式。  
- 如果使用Chisel，则建议不使用when和switch。  
  因为when和switch语义和Verilog HDL行为建模非常相似。  

简单来讲，在RTL代码编写过程中遵守“不编写任何always语句”的原则。  
下面提供触发器和选择器的Verilog模板以供调用：  





## 在NPC中实现第一条指令  


## 让程序决定仿真何时结束  
