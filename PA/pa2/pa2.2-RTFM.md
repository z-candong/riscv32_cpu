# RTFM
在上一小节中已经在概念上介绍了一条指令具体如何执行。 但当往TRM中添加各种高效指令的同时, 也意味着无法回避繁琐的细节.

首先需要了解指令确切的行为, 为此需要阅读生存手册中指令集相关的章节. 当前选择ISA为riscv32, 阅读手册并找到以下内容：
1. 每一条指令具体行为的描述
2. 指令opcode的编码表格

## RTFSC(2)
本节介绍NEMU的框架代码如何实现指令的执行.
在阅读NEMU源代码过程中，会遇到用于抽象ISA差异的大部分API。[本页面](https://ysyx.oscc.cc/docs/ics-pa/nemu-isa-api.html)对API功能进行了总结，在代码中遇到可查阅。

### 取指(instruction fetch, IF)


### 译码(instruction decode, ID)


### 执行(execute, EX)


### 更新PC


### 结构化程序设计


### 运行第一个C程序


### 运行更多的程序
未测试代码永远是错的, 因此需要更多的测试用例来测试你的NEMU。  
在``am-kernels/tests/cpu-tests/``目录下准备了一些简单的测试用例。在该目录下执行：  
```sh
make ARCH=$ISA-nemu ALL=xxx run
```
其中xxx为测试用例的名称(不包含.c后缀)。  
上述make run的命令最终会启动NEMU, 并运行相应的客户程序. 如果你需要使用GDB来调试NEMU运行客户程序的情况, 可以执行以下命令:  
```sh
make ARCH=$ISA-nemu ALL=xxx gdb
```
***
|***实验必做题：实现更多的指令***|
|-----------------|
|*实现更多的指令, 以通过上述测试用例.*|
|*可以自由选择按照什么顺序来实现指令.要养成尽早做测试的好习惯, 不要实现所有指令之后才进行测试.*| 
|*一般原则: 实现尽可能少的指令来进行下一次的测试.*| 
|*不需要实现所有指令的所有形式, 只需要通过这些测试即可。如果将来仍然遇到了未实现的指令, 就到时候再实现它们.*|
|*框架代码已经实现了部分指令, 但可能未编写相应的模式匹配规则.*|
|*此外, 部分函数的功能也并没有完全实现好(框架代码中已经插入了TODO()作为提示), 你还需要编写相应的功能.*|
|*由于string和hello-str还需要实现额外的内容才能运行(具体在后续小节介绍), 目前可以先使用其它测试用例进行测试.*|

注意: 根据对代码的理解和当下的需求判断需要添加哪些代码，而不是仅在出现TODO的地方写代码。
***

***
|***选做思考题：指令名对照***|
|-----------------------|
|*AT&T格式反汇编结果中的少量指令, 与手册中列出的指令名称不符, 如x86的cltd, mips32和riscv32则有不少伪指令(pseudo instruction). 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?*|
***

``PA2阶段1到此结束.``
