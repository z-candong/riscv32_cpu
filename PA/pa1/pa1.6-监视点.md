# 监视点  
监视点的功能是监视一个表达式的值何时发生变化. 如果从来没有使用过监视点, 请在GDB中体验一下它的作用.  

**注: 监视点主要用于当想要监控某个变量或内存地址的变化, 并且当这个变量或内存地址的值发生改变时，让程序暂停.**  

**示例:**   
在终端nemu目录下输入``make gdb``, 启动GDB调试nemu. 在GDB中输入如下指令:  
```
watch nemu_state
```
设置监视点. 然后``run``运行程序, 当nemu_state值发生改变时，程序会暂停打印出nemu_state变化信息.  
查看信息后，输入``continue``可以继续程序的运行, 直到遇到下一个使nemu_state发生变化的位置.  

## 扩展表达式求值的功能  
之前已经实现了算术表达式的求值, 但这些表达式都是由常数组成的, 它们的值不会发生变化. 这样的表达式在监视点中没有任何意义, 为了发挥监视点的功能, 你首先需要扩展表达式求值的功能.  

用BNF来说明需要扩展哪些功能:  
```
<expr> ::= <decimal-number>
  | <hexadecimal-number>    # 以"0x"开头
  | <reg_name>              # 以"$"开头
  | "(" <expr> ")"
  | <expr> "+" <expr>
  | <expr> "-" <expr>
  | <expr> "*" <expr>
  | <expr> "/" <expr>
  | <expr> "==" <expr>
  | <expr> "!=" <expr>
  | <expr> "&&" <expr>
  | "*" <expr>              # 指针解引用
```

它们的功能和C语言中运算符的功能是一致的, 包括优先级和结合性, 如有疑问, 请查阅相关资料.  

扩展功能说明:   
```
<expr> ::= <decimal-number>：一个表达式可以是一个十进制数。
<expr> ::= <hexadecimal-number>：或者，一个表达式也可以是一个十六进制数，这里注释指出十六进制数以"0x"开头。
<expr> ::= <reg_name>：表达式还可以是一个寄存器名称，这里的注释说明寄存器名称以"$"符号开头。
<expr> ::= "(" <expr> ")"：括号内的内容也是一个表达式，括号用于改变运算优先级或分组。
<expr> ::= <expr> "+" <expr>：两个表达式之间可以用加号连接形成一个新的表达式，表示加法操作。
<expr> ::= <expr> "-" <expr>：同上，但这里是减法操作。
<expr> ::= <expr> "*" <expr>：乘法操作。
<expr> ::= <expr> "/" <expr>：除法操作。
<expr> ::= <expr> "==" <expr>：等于比较，判断两边的表达式是否相等。
<expr> ::= <expr> "!=" <expr>：不等于比较。
<expr> ::= <expr> "&&" <expr>：逻辑与操作，通常用于布尔表达式的组合。
<expr> ::= "*" <expr>：指针解引用操作，意味着该表达式指向的内存位置的值。
```

关于获取寄存器的值, 这显然是一个ISA相关的功能. 框架代码已经准备了如下的API:  
```
// nemu/src/isa/$ISA/reg.c
word_t isa_reg_str2val(const char *s, bool *success);
```

它用于返回名字为s的寄存器的值, 并设置success指示是否成功.  

还需要注意的是指针解引用(dereference)的识别, 在进行词法分析的时候, 我们其实没有办法把乘法和指针解引用区别开来, 因为它们都是*.   
在进行递归求值之前, 我们需要将它们区别开来, 否则如果将指针解引用当成乘法来处理的话, 求值过程将会认为表达式不合法.   
其实要区别它们也不难, 给你一个表达式, 你也能将它们区别开来.   
实际上, 我们只要看*前一个token的类型, 我们就可以决定这个*是乘法还是指针解引用了, 不信你试试? 我们在这里给出expr()函数的框架:  
```C
if (!make_token(e)) {
  *success = false;
  return 0;
}

/* TODO: Implement code to evaluate the expression. */

for (i = 0; i < nr_token; i ++) {
  if (tokens[i].type == '*' && (i == 0 || tokens[i - 1].type == certain type) ) {
    tokens[i].type = DEREF;
  }
}

return eval(?, ?);
```

其中的certain type就由你自己来思考啦! 其实上述框架也可以处理负数问题, 如果你之前实现了负数, *的识别对你来说应该没什么困难了.

另外和GDB中的表达式相比, 我们做了简化, 简易调试器中的表达式没有类型之分, 因此我们需要额外说明两点:

• 所有结果都是uint32_t类型.
• 指针也没有类型, 进行指针解引用的时候, 我们总是从客户计算机的内存中读出一个uint32_t类型的整数.

***
|***实验必做题: 扩展表达式求值的功能***|
|-------------------------------|
|*你需要实现上述BNF中列出的功能.*|
|*上述BNF并没有列出C语言中所有的运算符, 例如各种位运算, <=等等. ==和&&很可能在使用监视点的时候用到, 因此要求你实现它们.*|
|*如果你在将来的使用中发现由于缺少某一个运算符而感到使用不方便, 到时候你再考虑实现它.*|
***

注意: 如果使用riscv32指令集, 则表达式求值结果要解释成uint32_t类型. 如果使用riscv64指令集, 则表达式求值结果解释为unit64_t类型.

我们之前实现了一个表达式生成器, 但给表达式求值加入了寄存器使用和指针解引用这两个功能之后, 表达式生成器就不能满足我们的所有需求了.   
这是因为在C程序中, 寄存器的语义并不存在, 而指针解引用的语义则与NEMU大不相同.  
这里想说明的是, 测试也会有局限性, 没有一种技术可以一劳永逸地解决所有问题.   
前沿的研究更是如此: 它们很多时候只能解决一小部分的问题.   
然而这个表达式生成器还是给你带来了很大的信心, 去思考如何方便地测试, 哪怕是进行一部分的测试, 也是有其价值的.

## 实现监视点
简易调试器允许用户同时设置多个监视点, 删除监视点, 因此我们最好使用链表将监视点的信息组织起来.  
框架代码中已经定义好了监视点的结构体(在nemu/src/monitor/sdb/watchpoint.c中):  
```C
typedef struct watchpoint {
  int NO;
  struct watchpoint *next;

  /* TODO: Add more members if necessary */

} WP;
```
但结构体中只定义了两个成员: NO表示监视点的序号, next就不用多说了吧.   
为了实现监视点的功能, 你需要根据你对监视点工作原理的理解在结构体中增加必要的成员.   
同时我们使用"池"的数据结构来管理监视点结构体, 框架代码中已经给出了一部分相关的代码:  
```C
static WP wp_pool[NR_WP] = {};
static WP *head = NULL, *free_ = NULL;
```
代码中定义了监视点结构的池wp_pool, 还有两个链表head和free_, 其中head用于组织使用中的监视点结构, free_用于组织空闲的监视点结构, init_wp_pool()函数会对两个链表进行初始化.  

***
|***实验必做题: 实现监视点池的管理***|
|-----------------|
|*为了使用监视点池, 你需要编写以下两个函数(你可以根据你的需要修改函数的参数和返回值):*|
|*其中new_wp()从free_链表中返回一个空闲的监视点结构, free_wp()将wp归还到free_链表中, 这两个函数会作为监视点池的接口被其它函数调用.*|
|*需要注意的是, 调用new_wp()时可能会出现没有空闲监视点结构的情况, 为了简单起见, 此时可以通过assert(0)马上终止程序. 框架代码中定义了32个监视点结构, 一般情况下应该足够使用, 如果你需要更多的监视点结构, 你可以修改NR_WP宏的值.*|
|*这两个函数里面都需要执行一些链表插入, 删除的操作, 对链表操作不熟悉的同学来说, 这可以作为一次链表的练习.*|
***




***
|***实验必做题: ***|
|-----------------|
|**|

***

