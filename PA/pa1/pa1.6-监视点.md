# 监视点  
监视点的功能是监视一个表达式的值何时发生变化. 如果从来没有使用过监视点, 请在GDB中体验一下它的作用.  

**注: 监视点主要用于当想要监控某个变量或内存地址的变化, 并且当这个变量或内存地址的值发生改变时，让程序暂停.**  

**示例:**   
在终端nemu目录下输入``make gdb``, 启动GDB调试nemu. 在GDB中输入如下指令:  
```
watch nemu_state
```
设置监视点. 然后``run``运行程序, 当nemu_state值发生改变时，程序会暂停打印出nemu_state变化信息.  
查看信息后，输入``continue``可以继续程序的运行, 直到遇到下一个使nemu_state发生变化的位置.  

## 扩展表达式求值的功能  
之前已经实现了算术表达式的求值, 但这些表达式都是由常数组成的, 它们的值不会发生变化. 这样的表达式在监视点中没有任何意义, 为了发挥监视点的功能, 你首先需要扩展表达式求值的功能.  

用BNF来说明需要扩展哪些功能:  
```
<expr> ::= <decimal-number>
  | <hexadecimal-number>    # 以"0x"开头
  | <reg_name>              # 以"$"开头
  | "(" <expr> ")"
  | <expr> "+" <expr>
  | <expr> "-" <expr>
  | <expr> "*" <expr>
  | <expr> "/" <expr>
  | <expr> "==" <expr>
  | <expr> "!=" <expr>
  | <expr> "&&" <expr>
  | "*" <expr>              # 指针解引用
```

它们的功能和C语言中运算符的功能是一致的, 包括优先级和结合性, 如有疑问, 请查阅相关资料.  

关于获取寄存器的值, 这显然是一个ISA相关的功能. 框架代码已经准备了如下的API:  
```
// nemu/src/isa/$ISA/reg.c
word_t isa_reg_str2val(const char *s, bool *success);
```

它用于返回名字为s的寄存器的值, 并设置success指示是否成功.  

还需要注意的是指针解引用(dereference)的识别, 在进行词法分析的时候, 我们其实没有办法把乘法和指针解引用区别开来, 因为它们都是*.   
在进行递归求值之前, 我们需要将它们区别开来, 否则如果将指针解引用当成乘法来处理的话, 求值过程将会认为表达式不合法.   
其实要区别它们也不难, 给你一个表达式, 你也能将它们区别开来.   
实际上, 我们只要看*前一个token的类型, 我们就可以决定这个*是乘法还是指针解引用了, 不信你试试? 我们在这里给出expr()函数的框架:  





