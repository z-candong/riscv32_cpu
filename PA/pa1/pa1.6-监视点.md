# 监视点  
监视点的功能是监视一个表达式的值何时发生变化. 如果从来没有使用过监视点, 请在GDB中体验一下它的作用.  

**注: 监视点主要用于当想要监控某个变量或内存地址的变化, 并且当这个变量或内存地址的值发生改变时，让程序暂停.**  

**示例:**   
在终端nemu目录下输入``make gdb``, 启动GDB调试nemu. 在GDB中输入如下指令:  
```
watch nemu_state
```
设置监视点. 然后``run``运行程序, 当nemu_state值发生改变时，程序会暂停打印出nemu_state变化信息.  
查看信息后，输入``continue``可以继续程序的运行, 直到遇到下一个使nemu_state发生变化的位置.  

## 扩展表达式求值的功能  
之前已经实现了算术表达式的求值, 但这些表达式都是由常数组成的, 它们的值不会发生变化. 这样的表达式在监视点中没有任何意义, 为了发挥监视点的功能, 你首先需要扩展表达式求值的功能.  

用BNF来说明需要扩展哪些功能:  
```
<expr> ::= <decimal-number>
  | <hexadecimal-number>    # 以"0x"开头
  | <reg_name>              # 以"$"开头
  | "(" <expr> ")"
  | <expr> "+" <expr>
  | <expr> "-" <expr>
  | <expr> "*" <expr>
  | <expr> "/" <expr>
  | <expr> "==" <expr>
  | <expr> "!=" <expr>
  | <expr> "&&" <expr>
  | "*" <expr>              # 指针解引用
```

它们的功能和C语言中运算符的功能是一致的, 包括优先级和结合性, 如有疑问, 请查阅相关资料.  

扩展功能说明:   
```
<expr> ::= <decimal-number>：一个表达式可以是一个十进制数。
<expr> ::= <hexadecimal-number>：或者，一个表达式也可以是一个十六进制数，这里注释指出十六进制数以"0x"开头。
<expr> ::= <reg_name>：表达式还可以是一个寄存器名称，这里的注释说明寄存器名称以"$"符号开头。
<expr> ::= "(" <expr> ")"：括号内的内容也是一个表达式，括号用于改变运算优先级或分组。
<expr> ::= <expr> "+" <expr>：两个表达式之间可以用加号连接形成一个新的表达式，表示加法操作。
<expr> ::= <expr> "-" <expr>：同上，但这里是减法操作。
<expr> ::= <expr> "*" <expr>：乘法操作。
<expr> ::= <expr> "/" <expr>：除法操作。
<expr> ::= <expr> "==" <expr>：等于比较，判断两边的表达式是否相等。
<expr> ::= <expr> "!=" <expr>：不等于比较。
<expr> ::= <expr> "&&" <expr>：逻辑与操作，通常用于布尔表达式的组合。
<expr> ::= "*" <expr>：指针解引用操作，意味着该表达式指向的内存位置的值。
```

关于获取寄存器的值, 这显然是一个ISA相关的功能. 框架代码已经准备了如下的API:  
```
// nemu/src/isa/$ISA/reg.c
word_t isa_reg_str2val(const char *s, bool *success);
```

它用于返回名字为s的寄存器的值, 并设置success指示是否成功.  

还需要注意的是指针解引用(dereference)的识别, 在进行词法分析的时候, 我们其实没有办法把乘法和指针解引用区别开来, 因为它们都是*.   
在进行递归求值之前, 我们需要将它们区别开来, 否则如果将指针解引用当成乘法来处理的话, 求值过程将会认为表达式不合法.   
其实要区别它们也不难, 给你一个表达式, 你也能将它们区别开来.   
实际上, 我们只要看*前一个token的类型, 我们就可以决定这个*是乘法还是指针解引用了, 不信你试试? 我们在这里给出expr()函数的框架:  
```C
if (!make_token(e)) {
  *success = false;
  return 0;
}

/* TODO: Implement code to evaluate the expression. */

for (i = 0; i < nr_token; i ++) {
  if (tokens[i].type == '*' && (i == 0 || tokens[i - 1].type == certain type) ) {
    tokens[i].type = DEREF;
  }
}

return eval(?, ?);
```

其中的certain type就由你自己来思考啦! 其实上述框架也可以处理负数问题, 如果你之前实现了负数, *的识别对你来说应该没什么困难了.

另外和GDB中的表达式相比, 我们做了简化, 简易调试器中的表达式没有类型之分, 因此我们需要额外说明两点:

• 所有结果都是uint32_t类型.
• 指针也没有类型, 进行指针解引用的时候, 我们总是从客户计算机的内存中读出一个uint32_t类型的整数.

***



***

